# Memory System Architecture Q&A

## Related Documents
- Memory component specification in [Component:Memory:2.0]
- Handler interface in [Interface:Handler:ResourceMonitoring:1.0]
- Memory Task Example in components/task-system/impl/examples.md
- Context Frame Pattern in [Pattern:ContextFrame:1.0]
- Resource Management Pattern in [Pattern:ResourceManagement:1.0]

## Memory and Context Concepts

Q: What exactly constitutes working memory?
A: The Memory System only manages two types of data:
1. Short-term task data context generated by associative matching
2. Global file metadata index for bootstrapping associative matching

The Handler manages all other task-related data including chat history and prompt handling.

Q: How is "context" different from "working memory"?
A: "Context" specifically refers to data context, while working memory is broader and includes chat history, system prompts, and templates. See [Pattern:ContextFrame:1.0] for details.

Q: What exactly does associative matching return?
A: Associative matching has two specific return values:
1. An unstructured data context section
2. A list of tuples containing absolute file paths and optional index strings for those files

## Component Responsibilities 

Q: Should the memory system track context window size?
A: No, this is delegated to the Handler (see [Interface:Handler:ResourceMonitoring:1.0]). The memory system stores content but doesn't track usage limits.

Q: Is the memory system responsible for managing system prompts and templates?
A: No, the Memory System does not handle prompts or templates at all. These are managed by the Task System and Handler.

Q: Who handles chat history?
A: The Handler manages all chat history and interaction state. The Memory System does not store any chat history.

Q: Who handles file content access?
A: File content access is handled by the LLM using Handler tools, not by the Memory System. The Memory System only provides the file paths and metadata needed to identify relevant files.

## Global Index

Q: What is the format of file metadata in the global index?
A: The metadata is simply stored as strings, with file paths as keys in a map structure. There is no predefined structure for the metadata content.

Q: What operations are supported on the global index?
A: The global index only supports two operations:
1. Getting the complete index
2. Bulk updates to the index
Individual updates, filtering, and querying are intentionally not supported to maintain simplicity.

## Context Management

Q: How can tasks get their data context?
A: Two ways (see operator specifications in components/task-system/spec/operators.md):
1. Inherit from parent/predecessor task
2. Generate fresh via associative matching using the global file metadata index as bootstrap. The associative matching task returns both context and a list of potentially relevant files, which can then be accessed using Handler tools.

Q: How does associative matching work when there's too much content?
A: When the full contents of all long-term storage files don't fit in the context window (times some factor), the associative matching task uses the existing global index to bootstrap the matching process. The input to the associative matching task includes all file paths in long-term storage.

Q: Should context inheritance vs. generation be a template parameter?
A: No, it should be part of the operator XML syntax in task library entries (see [Contract:Tasks:TemplateSchema:1.0]). It's not a substitutable parameter like task inputs.

Q: Can prior task output influence context generation?
A: Yes, the notes section of prior task output can be passed to associative matching for child/successor tasks. See Memory Task Example in components/task-system/impl/examples.md.

## Interface Design

Q: How should context source be controlled in the XML?
A: Through an optional inherit_context attribute on task elements, with defaults that can vary by operator type. See operator specifications in components/task-system/spec/operators.md.

## Implementation Questions

Q: Do operator defaults need to be standardized?
A: Not immediately. Different operators can have different context inheritance defaults based on their use cases. See operator specifications.

Q: How should context be handled in map/reduce operations?
A: The inherit_context attribute can be part of inner_task and reduction_task elements, following the same pattern as other operators. See operator specifications.

## Future Considerations

Q: When would file pre-extraction be considered?
A: File pre-extraction and concatenation is explicitly deferred for later consideration. The current design relies solely on tool-based file access via the Handler. Any performance optimizations through pre-extraction would only be considered after evaluating the effectiveness of the tool-based approach.