# Memory System Architecture Q&A

## Related Documents
- Memory component specification in [Component:Memory:1.0]
- Handler interface in [Interface:Handler:ResourceMonitoring:1.0]
- Memory Task Example in components/task-system/impl/examples.md
- Context Frame Pattern in [Pattern:ContextFrame:1.0]
- Resource Management Pattern in [Pattern:ResourceManagement:1.0]

## Memory and Context Concepts

Q: What exactly constitutes working memory?
A: Working memory includes four components (see Memory System Types in components/task-system/spec/types.md):
1. The data context generated by associative matching
2. The 'chat' component from LLM-handler interaction
3. The system prompt
4. The prompt template (after population with inputs and parameters)

Q: How is "context" different from "working memory"?
A: "Context" specifically refers to data context, while working memory is broader and includes context plus chat history, system prompts, and templates. See [Pattern:ContextFrame:1.0] for details.

## Component Responsibilities 

Q: Should the memory system track context window size?
A: No, this is delegated to the Handler (see [Interface:Handler:ResourceMonitoring:1.0]). The memory system stores content but doesn't track usage limits.

Q: Is the memory system responsible for managing system prompts and templates?
A: No, it only stores them. Management is handled by the task system (see [Contract:Tasks:TemplateSchema:1.0]) and handler.

Q: Who handles chat history?
A: The Handler manages chat history as specified in [Interface:Handler:ResourceMonitoring:1.0]. Memory system only stores it as part of working memory.

## Context Management

Q: How can tasks get their data context?
A: Two ways (see operator specifications in components/task-system/spec/operators.md):
1. Inherit from parent/predecessor task
2. Generate fresh via associative matching against long-term memory

Q: Should context inheritance vs. generation be a template parameter?
A: No, it should be part of the operator XML syntax in task library entries (see [Contract:Tasks:TemplateSchema:1.0]). It's not a substitutable parameter like task inputs.

Q: Can prior task output influence context generation?
A: Yes, the notes section of prior task output can be passed to associative matching for child/successor tasks. See Memory Task Example in components/task-system/impl/examples.md.

## Interface Design

Q: How should context source be controlled in the XML?
A: Through an optional inherit_context attribute on task elements, with defaults that can vary by operator type. See operator specifications in components/task-system/spec/operators.md.

Q: Why is TaskResult.notes changing to an unstructured string?
A: To allow maximum flexibility in what can be passed to associative matching, removing the unnecessary structure of the dataUsage field. See TaskResult interface in components/task-system/api/interfaces.md.

Q: Are there any backward compatibility concerns with changing TaskResult.notes?
A: Review of the codebase shows no meaningful usage of the dataUsage field, suggesting minimal impact from this change.

## Implementation Questions

Q: Do operator defaults need to be standardized?
A: Not immediately. Different operators can have different context inheritance defaults based on their use cases. See operator specifications.

Q: How should context be handled in map/reduce operations?
A: The inherit_context attribute can be part of inner_task and reduction_task elements, following the same pattern as other operators. See operator specifications.

## Future Considerations

Q: Could structured notes be useful in the future?
A: If needed, structure can be encoded within the string format. Current use cases don't justify enforcing structure. See TaskResult interface.